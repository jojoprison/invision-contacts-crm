# Тестирование мультитенантного приложения Django-Ninja

## Архитектура мультитенантности

В проекте используется подход мультитенантности на основе **схем PostgreSQL**:

- Каждый тенант (арендатор) имеет свою схему в базе данных PostgreSQL
- Схемы изолированы друг от друга и имеют префикс `contact_`
- Middleware автоматически определяет схему на основе заголовка `X-SCHEMA` в запросе
- Все таблицы (например, `contacts_contact`) создаются отдельно в каждой схеме тенанта

## Настройка тестового окружения

Для запуска тестов используется pytest с дополнительными фикстурами для мультитенантной архитектуры:

### Основные фикстуры

- `setup_tenants`: Создает тестовые схемы, применяет миграции и очищает данные после тестов
- `tenant1_client`, `tenant2_client`: Django клиенты с настроенными заголовками X-SCHEMA
- `no_schema_client`: Клиент без заголовка схемы (для тестирования ошибок)
- `invalid_schema_client`: Клиент с невалидным заголовком схемы
- `create_contact`: Вспомогательная функция для создания контактов через API

### Процесс инициализации

1. Удаляются существующие тенанты из таблицы `tenants`
2. Удаляются схемы PostgreSQL (если они существуют) с использованием `DROP SCHEMA CASCADE`
3. Создаются новые схемы с помощью SQL-команды `CREATE SCHEMA`
4. Создаются записи тенантов в таблице `tenants`
5. Применяются миграции к каждой схеме отдельно через `call_command('migrate_tenant_schema', schema_name)`
6. После завершения тестов все схемы и тенанты очищаются автоматически через механизм `yield` в фикстуре `setup_tenants`

## Особенности тестирования

### Изоляция данных

Тесты проверяют изоляцию данных между тенантами:

- `test_email_uniqueness_per_tenant`: Проверяет, что контакты с одинаковыми email могут существовать в разных тенантах
- `test_contact_count_isolation`: Проверяет, что количество контактов в одном тенанте не влияет на другой

### Валидация данных

Тесты проверяют валидацию данных:

- `test_create_contact_with_invalid_email`: Проверяет, что API отклоняет невалидный формат email

#### Реализация валидации email

Валидация email осуществляется через Pydantic Field с использованием регулярного выражения:

```python
email: str = Field(
    ...,
    pattern=r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$',
    description="Валидный email адрес"
)
```

### Middleware

Тесты проверяют работу middleware тенантов:

- `test_no_schema_header`: Проверяет ответ, когда отсутствует заголовок X-SCHEMA
- `test_invalid_schema`: Проверяет ответ для несуществующей схемы

## Запуск тестов

```bash
# Запуск всех тестов
docker-compose exec web pytest src/tests/

# Запуск конкретного теста
docker-compose exec web pytest src/tests/tenant_isolation_test.py::test_email_uniqueness_per_tenant

# Запуск с подробным выводом
docker-compose exec web pytest src/tests/ -v

# Запуск с отображением вывода в консоль в реальном времени
docker-compose exec web pytest src/tests/ -v -s
```

## Особенности реализации

### Префиксы схем

Константа `TENANT_SCHEMA_PREFIX = 'contact_'` определена в настройках приложения и используется для:

- Автоматического добавления префикса в middleware
- Создания схем в тестах
- Поиска тенантов в базе данных

### Миграции для схем тенантов

Для применения миграций к схеме тенанта используется команда:

```python
call_command('migrate_tenant_schema', schema_name)
```

Эта команда выполняет миграции Django в контексте указанной схемы PostgreSQL.

### Настройки базы данных для тестов

Тесты используют обычную базу данных приложения (не создают отдельную тестовую базу).
В этом случае важно, чтобы тесты корректно очищали за собой данные, что обеспечивается
механизмом очистки после завершения тестов.

### Генерация уникальных данных для тестов

Для предотвращения конфликтов при повторном запуске тестов используется генерация уникальных идентификаторов с помощью UUID:

```python
import uuid
unique_id = str(uuid.uuid4())[:8]
email = f"test-{unique_id}@example.com"
```

## Типичные проблемы и решения

### 1. Ошибка "relation does not exist"

**Проблема**: Тесты сообщают, что таблица (например, `contacts_contact`) не существует.

**Решение**: 
- Убедиться, что схема создана
- Проверить, что миграции применены к схеме
- Использовать прямые SQL-запросы для проверки наличия таблицы в схеме

### 2. Конфликты уникальных ограничений

**Проблема**: Тесты падают с ошибкой `duplicate key value violates unique constraint`.

**Решение**:
- Генерировать уникальные данные для каждого теста с помощью UUID
- Убедиться, что тестовая среда корректно очищается после каждого теста
- Использовать механизм транзакций для изоляции тестов

### 3. Проблемы с правами доступа

**Проблема**: Ошибки вида "permission denied" при создании схем.

**Решение**:
- Убедиться, что пользователь базы данных имеет права на создание/удаление схем
- Добавить права через команду: `ALTER USER username CREATEDB;`

### 4. Ошибки "Database access not allowed"

**Проблема**: Django тесты сообщают, что доступ к базе данных запрещен.

**Решение**:
- Добавить `@pytest.mark.django_db` к тестовым функциям
- Использовать фикстуру `db` в аргументах фикстур, требующих доступ к БД
- Убедиться, что для всех тестов в директории включена автоматическая метка django_db в конфигурации pytest
