# Тестирование мультитенантного приложения Django-Ninja

## Архитектура мультитенантности

В проекте используется подход мультитенантности на основе **схем PostgreSQL**:

- Каждый тенант (арендатор) имеет свою схему в базе данных PostgreSQL
- Схемы изолированы друг от друга и имеют префикс `contact_`
- Middleware автоматически определяет схему на основе заголовка `X-SCHEMA` в запросе
- Все таблицы (например, `contacts_contact`) создаются отдельно в каждой схеме тенанта

## Настройка тестового окружения

Для запуска тестов используется pytest с дополнительными фикстурами для мультитенантной архитектуры:

### Основные фикстуры

- `setup_tenants`: Создает тестовые схемы, применяет миграции и очищает данные после тестов
- `tenant1_client`, `tenant2_client`: Django клиенты с настроенными заголовками X-SCHEMA
- `no_schema_client`: Клиент без заголовка схемы (для тестирования ошибок)
- `invalid_schema_client`: Клиент с невалидным заголовком схемы
- `create_contact`: Вспомогательная функция для создания контактов через API

### Процесс инициализации

1. Удаляются существующие тенанты из таблицы `tenants`
2. Удаляются схемы PostgreSQL (если они существуют) с использованием `DROP SCHEMA CASCADE`
3. Создаются новые схемы с помощью SQL-команды `CREATE SCHEMA`
4. Создаются записи тенантов в таблице `tenants`
5. Применяются миграции к каждой схеме отдельно через `call_command('migrate_tenant_schema', schema_name)`
6. После завершения тестов все схемы и тенанты очищаются автоматически через механизм `yield` в фикстуре `setup_tenants`

## Особенности тестирования

### Изоляция данных

Тесты проверяют изоляцию данных между тенантами:

- `test_email_uniqueness_per_tenant`: Проверяет, что контакты с одинаковыми email могут существовать в разных тенантах
- `test_contact_count_isolation`: Проверяет, что количество контактов в одном тенанте не влияет на другой

### Валидация данных

Тесты проверяют валидацию данных:

- `test_create_contact_with_invalid_email`: Проверяет, что API отклоняет невалидный формат email

#### Реализация валидации email

Валидация email осуществляется через Pydantic Field с использованием регулярного выражения:

```python
email: str = Field(
    ...,
    pattern=r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$',
    description="Валидный email адрес"
)
```

### Middleware

Тесты проверяют работу middleware тенантов:

- `test_no_schema_header`: Проверяет ответ, когда отсутствует заголовок X-SCHEMA
- `test_invalid_schema`: Проверяет ответ для несуществующей схемы

### Команды управления

Тесты проверяют работу команд управления тенантами:

- `test_create_tenant_command`: Проверяет создание тенанта и схемы
- `test_delete_tenant_command`: Проверяет удаление тенанта и схемы
- `test_migrate_tenant_schema_command`: Проверяет применение миграций к схеме тенанта
- `test_setup_environment_command`: Проверяет настройку окружения

## Запуск тестов

```bash
# Запуск всех тестов
docker-compose exec web pytest src/tests/

# Запуск конкретного теста
docker-compose exec web pytest src/tests/tenant_isolation_test.py::test_email_uniqueness_per_tenant

# Запуск с подробным выводом
docker-compose exec web pytest src/tests/ -v

# Запуск с отображением вывода в консоль в реальном времени
docker-compose exec web pytest src/tests/ -v -s

# Запуск с проверкой покрытия кода тестами
docker-compose exec web pytest src/tests/ --cov=src --cov-report=term

# Генерация HTML-отчета о покрытии
docker-compose exec web pytest src/tests/ --cov=src --cov-report=html
```

## Проверка покрытия кода тестами

Для проверки и анализа покрытия кода тестами используется плагин `pytest-cov`. 

### Настройка покрытия тестами

В корне проекта находится файл `.coveragerc`, который настраивает процесс сбора информации о покрытии:

```ini
[run]
omit =
    src/app/asgi.py
    src/app/wsgi.py
    src/manage.py
    src/*/migrations/*
    src/*/tests.py

[report]
exclude_lines =
    pragma: no cover
    def __str__
    def __repr__
    raise NotImplementedError
    if __name__ == .__main__.:
    pass
    raise ImportError
```

Этот файл исключает из отчета о покрытии:
- Конфигурационные файлы (`asgi.py`, `wsgi.py`, `manage.py`)
- Файлы миграций
- Пустые тестовые файлы

Текущее покрытие кода тестами составляет более **90%**, что является хорошим показателем для проекта.

## Особенности реализации

### Префиксы схем

Константа `TENANT_SCHEMA_PREFIX = 'contact_'` определена в настройках приложения и используется для:

- Автоматического добавления префикса в middleware
- Создания схем в тестах
- Поиска тенантов в базе данных

### Миграции для схем тенантов

Для применения миграций к схеме тенанта используется команда:

```python
call_command('migrate_tenant_schema', schema_name)
```

## Устранение типичных проблем

### 404 ошибка при обращении к API

- **Проблема**: API возвращает 404, хотя URL верный
- **Причина**: Скорее всего, проблема в схеме тенанта или заголовке X-SCHEMA
- **Решение**: Проверить, что схема создана и префикс `contact_` добавлен

### Ошибки доступа к базе данных

- **Проблема**: Ошибка доступа к таблицам в схеме тенанта
- **Причина**: Не применены миграции к схеме тенанта
- **Решение**: Использовать `call_command('migrate_tenant_schema', schema_name)`

### Проблема с тестами фикстур

- **Проблема**: Ошибка `django.db.utils.ProgrammingError`
- **Причина**: Фикстура не имеет доступа к базе данных
- **Решение**: Добавить `@pytest.mark.django_db` к тестовым функциям или параметр `db` к фикстуре

### Проблемы с дублированием данных

- **Проблема**: Тесты падают с UniqueConstraint
- **Причина**: Предыдущие тесты не очистили данные
- **Решение**: Использовать уникальные идентификаторы (UUID) для тестовых данных и правильную очистку

## Советы по написанию тестов

### Генерация уникальных идентификаторов

Для предотвращения конфликтов между тестами:

```python
import uuid

# Создание уникального email для каждого теста
test_email = f"test_{uuid.uuid4().hex[:8]}@example.com"
```

### Правильная очистка после тестов

```python
@pytest.fixture
def setup_test_data(db):
    # Создание тестовых данных
    tenant = Tenant.objects.create(name="test", schema_name="contact_test")
    
    yield tenant  # Предоставляем данные для теста
    
    # Очистка после завершения теста
    tenant.delete()
    with connection.cursor() as cursor:
        cursor.execute("DROP SCHEMA IF EXISTS contact_test CASCADE")
```

### Маркировка для доступа к базе данных

- Добавить `@pytest.mark.django_db` к тестовым функциям
- Использовать фикстуру `db` в аргументах фикстур, требующих доступ к БД
- Убедиться, что для всех тестов в директории включена автоматическая метка django_db в конфигурации pytest
